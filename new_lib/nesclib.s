;
; File generated by cc65 v 2.19 - N/A
;
	.fopt		compiler,"cc65 v 2.19 - N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.export		__update_nt_text
	.export		_nes_load_title
	.export		_nes_load_title_a
	.export		_nes_load_title_b
	.export		_nes_hud_update
	.export		_nes_fade_transition_fg
	.export		_nes_fade_transition_bg
	.export		_nes_show_region_error
	.export		_nes_exit_cleanup
	.export		_nes_fade_out
	.export		_nes_fade_in
	.export		_nes_palette_rand
	.export		_nes_text_log
	.export		_nes_text_hud
	.export		_nes_clear_nametable
	.export		__print_nt_text

.segment	"DATA"

_update_index:
	.byte	$00
_xText:
	.word	$0000
_yText:
	.word	$0000

.segment	"RODATA"

S0002:
	.byte	$50,$4C,$45,$41,$53,$45,$20,$53,$57,$49,$54,$43,$48,$20,$54,$4F
	.byte	$20,$50,$41,$4C,$20,$4F,$52,$20,$44,$45,$4E,$44,$59,$00
S0003:
	.byte	$57,$52,$4F,$4E,$47,$20,$56,$49,$44,$45,$4F,$20,$52,$45,$47,$49
	.byte	$4F,$4E,$20,$53,$45,$4C,$45,$43,$54,$45,$44,$0A,$00
S0001	:=	S0003+0
S0004:
	.byte	$50,$4C,$45,$41,$53,$45,$20,$53,$57,$49,$54,$43,$48,$20,$54,$4F
	.byte	$20,$4E,$54,$53,$43,$00

.segment	"BSS"

_gpit:
	.res	1,$00
_rda:
	.res	1,$00
_gp_addr:
	.res	2,$00
_update_list:
	.res	91,$00
_ppu_region:
	.res	1,$00
_fade_index:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ _update_nt_text (unsigned char x, unsigned char y, unsigned char l, char *s)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__update_nt_text: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; gp_addr = NAMETABLE_A + (y << 5) + x;
;
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     tmp1
	clc
	adc     #$20
	sta     ptr1+1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L0006
	inx
L0006:	sta     _gp_addr
	stx     _gp_addr+1
;
; UPDATE_NT_BUF = MSB(gp_addr) | NT_UPD_HORZ; // Horizontal type text. change to NT_UPD_VERT for Vertical text
;
	lda     _update_index
	inc     _update_index
	clc
	adc     #<(_update_list)
	sta     ptr1
	lda     #$00
	adc     #>(_update_list)
	sta     ptr1+1
	lda     _gp_addr+1
	ora     #$40
	ldy     #$00
	sta     (ptr1),y
;
; UPDATE_NT_BUF = LSB(gp_addr);
;
	lda     _update_index
	inc     _update_index
	clc
	adc     #<(_update_list)
	sta     ptr1
	tya
	adc     #>(_update_list)
	sta     ptr1+1
	lda     _gp_addr
	sta     (ptr1),y
;
; UPDATE_NT_BUF = l; //l - length of text.
;
	lda     _update_index
	inc     _update_index
	clc
	adc     #<(_update_list)
	sta     ptr1
	tya
	adc     #>(_update_list)
	sta     ptr1+1
	ldy     #$02
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; gpit = l;
;
	ldy     #$02
	lda     (sp),y
	sta     _gpit
;
; while (gpit--)
;
	jmp     L0007
;
; UPDATE_NT_BUF = *s++ + NES_TEXT_TILE_INDEX - 0x20;
;
L0002:	lda     _update_index
	inc     _update_index
	clc
	adc     #<(_update_list)
	sta     sreg
	lda     #$00
	adc     #>(_update_list)
	sta     sreg+1
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	sec
	sbc     #$20
	sta     (sreg),y
	ldx     #$00
	lda     #$01
	jsr     addeq0sp
;
; while (gpit--)
;
L0007:	lda     _gpit
	dec     _gpit
	tax
	bne     L0002
;
; }
;
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ _vram_text (const char *text, int textX, int textY)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__vram_text: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(NTADR_A(textX, textY));
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; while (*text)
;
	jmp     L0004
;
; vram_put((*text++) + NES_TEXT_TILE_INDEX - 0x20);
;
L0002:	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sec
	sbc     #$20
	pha
	ldy     #$04
	ldx     #$00
	lda     #$01
	jsr     addeqysp
	pla
	jsr     _vram_put
;
; while (*text)
;
L0004:	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	bne     L0002
;
; }
;
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ nes_load_title (char *title, unsigned int nametable)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_load_title: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(nametable);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; vram_unrle(title);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_unrle
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ nes_load_title_a (char *title)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_load_title_a: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(title);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_unrle
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ nes_load_title_b (char *title)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_load_title_b: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(NAMETABLE_B);
;
	ldx     #$24
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(title);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_unrle
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ nes_hud_update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_hud_update: near

.segment	"CODE"

;
; update_list[update_index] = NT_UPD_EOF;
;
	ldy     _update_index
	lda     #$FF
	sta     _update_list,y
;
; update_index = 0; // Reset update list
;
	lda     #$00
	sta     _update_index
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ nes_fade_transition_fg (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_fade_transition_fg: near

.segment	"CODE"

;
; if (get_frame_count() % (1 << 4) == 0)
;
	jsr     _get_frame_count
	and     #$0F
	bne     L0002
;
; pal_col(1, rand8() & 4);
;
	lda     #$01
	jsr     pusha
	jsr     _rand8
	and     #$04
	jsr     _pal_col
;
; pal_col(3, rand8() & 4);
;
	lda     #$03
	jsr     pusha
	jsr     _rand8
	and     #$04
	jsr     _pal_col
;
; delay(10);
;
	lda     #$0A
	jmp     _delay
;
; }
;
L0002:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ nes_fade_transition_bg (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_fade_transition_bg: near

.segment	"CODE"

;
; if (get_frame_count() % (1 << 4) == 0)
;
	jsr     _get_frame_count
	and     #$0F
	bne     L0002
;
; pal_col(0, rand8() & 4);
;
	jsr     pusha
	jsr     _rand8
	and     #$04
	jsr     _pal_col
;
; pal_col(2, rand8() & 4);
;
	lda     #$02
	jsr     pusha
	jsr     _rand8
	and     #$04
	jsr     _pal_col
;
; delay(10);
;
	lda     #$0A
	jmp     _delay
;
; }
;
L0002:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ nes_show_region_error (unsigned char region_type)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_show_region_error: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; ppu_region = REGION_DENDY + 1; //Error set initial.
;
	lda     #$03
	sta     _ppu_region
;
; if (ppu_system() && region_type == REGION_NTSC)
;
	jsr     _ppu_system
	tax
	beq     L0002
	ldy     #$00
	lda     (sp),y
	bne     L0002
;
; NES_GOTOXY(3, 15);
;
	tax
	lda     #$03
	sta     _xText
	stx     _xText+1
	lda     #$0F
	sta     _yText
	stx     _yText+1
;
; nes_text_hud("WRONG VIDEO REGION SELECTED\n");
;
	lda     #<(S0001)
	ldx     #>(S0001)
	jsr     pushax
	ldy     #$02
	jsr     _nes_text_hud
;
; NES_GOTOXY(3, 17);
;
	ldx     #$00
	lda     #$03
	sta     _xText
	stx     _xText+1
	lda     #$11
	sta     _yText
	stx     _yText+1
;
; nes_text_hud("PLEASE SWITCH TO PAL OR DENDY");
;
	lda     #<(S0002)
	ldx     #>(S0002)
	jsr     pushax
	ldy     #$02
	jsr     _nes_text_hud
;
; ppu_region = REGION_NTSC;
;
	lda     #$00
;
; else if (!ppu_system() && region_type == REGION_PAL || region_type == REGION_DENDY)
;
	jmp     L000F
L0002:	jsr     _ppu_system
	tax
	bne     L0008
	lda     (sp,x)
	cmp     #$01
	beq     L0015
L0008:	ldy     #$00
	lda     (sp),y
	cmp     #$02
	bne     L0016
;
; NES_GOTOXY(3, 15);
;
	ldx     #$00
L0015:	lda     #$03
	sta     _xText
	stx     _xText+1
	lda     #$0F
	sta     _yText
	stx     _yText+1
;
; nes_text_hud("WRONG VIDEO REGION SELECTED\n");
;
	lda     #<(S0003)
	ldx     #>(S0003)
	jsr     pushax
	ldy     #$02
	jsr     _nes_text_hud
;
; NES_GOTOXY(3, 17);
;
	ldx     #$00
	lda     #$03
	sta     _xText
	stx     _xText+1
	lda     #$11
	sta     _yText
	stx     _yText+1
;
; nes_text_hud("PLEASE SWITCH TO NTSC");
;
	lda     #<(S0004)
	ldx     #>(S0004)
	jsr     pushax
	ldy     #$02
	jsr     _nes_text_hud
;
; ppu_region = REGION_PAL;
;
	lda     #$01
L000F:	sta     _ppu_region
;
; if (ppu_region <= REGION_DENDY)
;
L0016:	lda     _ppu_region
	cmp     #$03
	bcs     L000D
;
; nes_clear_nametable(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _nes_clear_nametable
;
; nes_hud_update();
;
	jsr     _nes_hud_update
;
; set_vram_update(update_list);
;
	lda     #<(_update_list)
	ldx     #>(_update_list)
	jsr     _set_vram_update
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; ppu_wait_nmi();
;
L000C:	jsr     _ppu_wait_nmi
;
; nes_fade_transition_fg();
;
	jsr     _nes_fade_transition_fg
;
; while (TRUE)
;
	jmp     L000C
;
; }
;
L000D:	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ nes_exit_cleanup (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_exit_cleanup: near

.segment	"CODE"

;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; oam_clear();
;
	jsr     _oam_clear
;
; music_stop();
;
	jsr     _music_stop
;
; nes_fade_out();
;
	jsr     _nes_fade_out
;
; ppu_off();
;
	jmp     _ppu_off

.endproc

; ---------------------------------------------------------------
; void __near__ nes_fade_out (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_fade_out: near

.segment	"CODE"

;
; for (fade_index = 4; fade_index > 0; fade_index--)
;
	lda     #$04
	sta     _fade_index
L0006:	lda     _fade_index
	beq     L0003
;
; pal_bright(fade_index);
;
	jsr     _pal_bright
;
; delay(FADE_DELAY);
;
	lda     #$04
	jsr     _delay
;
; for (fade_index = 4; fade_index > 0; fade_index--)
;
	dec     _fade_index
	jmp     L0006
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ nes_fade_in (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_fade_in: near

.segment	"CODE"

;
; for (fade_index = 0; fade_index < 5; fade_index++)
;
	lda     #$00
	sta     _fade_index
L0006:	lda     _fade_index
	cmp     #$05
	bcs     L0003
;
; pal_bright(fade_index);
;
	jsr     _pal_bright
;
; delay(FADE_DELAY);
;
	lda     #$04
	jsr     _delay
;
; for (fade_index = 0; fade_index < 5; fade_index++)
;
	inc     _fade_index
	jmp     L0006
;
; }
;
L0003:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ nes_palette_rand (unsigned char paletteType)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_palette_rand: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; uint8_t bgPalette[16] = {NULL}, sprPalette[16] = {NULL};
;
	ldy     #$10
	jsr     subysp
	ldy     #$0F
L0002:	lda     M0001,y
	sta     (sp),y
	dey
	bpl     L0002
	ldy     #$10
	jsr     subysp
	ldy     #$0F
L0003:	lda     M0002,y
	sta     (sp),y
	dey
	bpl     L0003
;
; uint8_t i = 0;
;
	lda     #$00
	jsr     pusha
;
; for (i = 0; i < 16; ++i)
;
	tay
L0015:	sta     (sp),y
	cmp     #$10
	jcs     L0005
;
; bgPalette[i] = (i + rand8() + (i * 2)) % 0x3F;
;
	lda     sp
	ldx     sp+1
	clc
	adc     #$11
	bcc     L001A
	inx
	clc
L001A:	adc     (sp),y
	bcc     L0009
	inx
L0009:	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     pusha0
	jsr     _rand8
	jsr     tosaddax
	jsr     pushax
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	asl     a
	bcc     L0014
	inx
L0014:	jsr     tosaddax
	jsr     pushax
	ldx     #$00
	lda     #$3F
	jsr     tosmoda0
	ldy     #$00
	jsr     staspidx
;
; sprPalette[i] = (i + rand8() + (i * 1)) % 0x3F;
;
	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L000A
	inx
L000A:	ldy     #$00
	clc
	adc     (sp),y
	bcc     L000B
	inx
L000B:	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     pusha0
	jsr     _rand8
	jsr     tosaddax
	jsr     pushax
	ldy     #$04
	lda     (sp),y
	jsr     tosadda0
	jsr     pushax
	ldx     #$00
	lda     #$3F
	jsr     tosmoda0
	ldy     #$00
	jsr     staspidx
;
; for (i = 0; i < 16; ++i)
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0015
;
; if (paletteType == PALETTE_TYPE_BG)
;
L0005:	ldy     #$21
	lda     (sp),y
	bne     L0018
;
; pal_bg(bgPalette);
;
	lda     sp
	ldx     sp+1
	clc
	adc     #$11
	bcc     L000D
	inx
L000D:	jsr     _pal_bg
;
; else if (paletteType == PALETTE_TYPE_SPR)
;
	jmp     L0011
L0018:	lda     (sp),y
	cmp     #$01
;
; else
;
	beq     L001F
;
; pal_bg(bgPalette);
;
	lda     sp
	ldx     sp+1
	clc
	adc     #$11
	bcc     L0012
	inx
L0012:	jsr     _pal_bg
;
; pal_spr(sprPalette);
;
L001F:	lda     sp
	ldx     sp+1
	clc
	adc     #$01
	bcc     L0013
	inx
L0013:	jsr     _pal_spr
;
; }
;
L0011:	ldy     #$22
	jmp     addysp

.segment	"RODATA"

M0001:
	.byte	$00
	.res	15,$00
M0002:
	.byte	$00
	.res	15,$00

.endproc

; ---------------------------------------------------------------
; void __near__ nes_text_log (const char *format, ...)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_text_log: near

.segment	"CODE"

;
; {
;
	jsr     enter
;
; char textBuf[0x32] = {NULL};
;
	ldy     #$32
	jsr     subysp
	ldy     #$31
L0002:	lda     M0001,y
	sta     (sp),y
	dey
	bpl     L0002
;
; va_start(args, format);
;
	jsr     decsp2
	ldy     #$34
	lda     (sp),y
	jsr     leaa0sp
	clc
	adc     #$33
	bcc     L0003
	inx
L0003:	jsr     stax0sp
;
; vsprintf(textBuf, format, args);
;
	jsr     decsp4
	lda     sp
	ldx     sp+1
	clc
	adc     #$06
	bcc     L0004
	inx
L0004:	ldy     #$02
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$38
	lda     (sp),y
	jsr     leaa0sp
	clc
	adc     #$37
	bcc     L0005
	inx
L0005:	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vsprintf
;
; if (wherex() > TILES_X)
;
	jsr     _wherex
	cmp     #$1F
	bcc     L0008
;
; yText++;
;
	inc     _yText
	bne     L0007
	inc     _yText+1
;
; xText = 0;
;
L0007:	lda     #$00
	sta     _xText
	sta     _xText+1
;
; if (yText > TILES_Y)
;
	lda     _yText
	cmp     #$1D
	lda     _yText+1
	sbc     #$00
	bvs     L0009
	eor     #$80
L0009:	bpl     L0008
;
; yText = 1;
;
	ldx     #$00
	lda     #$01
	sta     _yText
	stx     _yText+1
;
; gotoxy(xText, yText);
;
L0008:	lda     _xText
	jsr     pusha
	lda     _yText
	jsr     _gotoxy
;
; _vram_text(textBuf, xText++, yText);
;
	jsr     decsp4
	lda     sp
	ldx     sp+1
	clc
	adc     #$06
	bcc     L000A
	inx
L000A:	ldy     #$02
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     _xText
	ldy     #$00
	sta     (sp),y
	iny
	lda     _xText+1
	sta     (sp),y
	inc     _xText
	bne     L000B
	inc     _xText+1
L000B:	lda     _yText
	ldx     _yText+1
	jsr     __vram_text
;
; if (textBuf[strlen(textBuf) - 1] == '\n')
;
	ldx     #$FF
	ldy     #$01
L000D:	inx
	iny
	lda     (sp),y
	bne     L000D
	txa
	ldx     #$00
	sec
	sbc     #$01
	bcs     L000E
	dex
L000E:	clc
	adc     #$02
	bcc     L000F
	inx
	clc
L000F:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$0A
	bne     L000C
;
; yText++;
;
	inc     _yText
	bne     L0010
	inc     _yText+1
;
; xText = 0;
;
L0010:	tya
	sta     _xText
	sta     _xText+1
;
; if (textBuf[strlen(textBuf) - 1] == '\t')
;
L000C:	ldx     #$FF
	iny
L0012:	inx
	iny
	lda     (sp),y
	bne     L0012
	txa
	ldx     #$00
	sec
	sbc     #$01
	bcs     L0013
	dex
L0013:	clc
	adc     #$02
	bcc     L0014
	inx
	clc
L0014:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$09
	bne     L0011
;
; xText += strlen(textBuf) + 4;
;
	dex
	ldy     #$01
L0015:	inx
	iny
	lda     (sp),y
	bne     L0015
	txa
	ldx     #$00
	clc
	adc     #$04
	bcc     L0017
	inx
	clc
L0017:	adc     _xText
	sta     _xText
	txa
	adc     _xText+1
	sta     _xText+1
	tax
	lda     _xText
;
; }
;
L0011:	ldy     #$34
	jmp     leavey

.segment	"RODATA"

M0001:
	.byte	$00
	.res	49,$00

.endproc

; ---------------------------------------------------------------
; void __near__ nes_text_hud (const char *format, ...)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_text_hud: near

.segment	"CODE"

;
; {
;
	jsr     enter
;
; char textBuf[32] = {NULL};
;
	ldy     #$20
	jsr     subysp
	ldy     #$1F
L0002:	lda     M0001,y
	sta     (sp),y
	dey
	bpl     L0002
;
; va_start(args, format);
;
	jsr     decsp2
	ldy     #$22
	lda     (sp),y
	jsr     leaa0sp
	clc
	adc     #$21
	bcc     L0003
	inx
L0003:	jsr     stax0sp
;
; vsprintf(textBuf, format, args);
;
	jsr     decsp4
	lda     sp
	ldx     sp+1
	clc
	adc     #$06
	bcc     L0004
	inx
L0004:	ldy     #$02
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$26
	lda     (sp),y
	jsr     leaa0sp
	clc
	adc     #$25
	bcc     L0005
	inx
L0005:	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vsprintf
;
; _update_nt_text(xText, yText, strlen(textBuf), textBuf);
;
	jsr     decsp3
	lda     _xText
	ldy     #$02
	sta     (sp),y
	lda     _yText
	dey
	sta     (sp),y
	ldx     #$FF
	ldy     #$04
L0006:	inx
	iny
	lda     (sp),y
	bne     L0006
	txa
	ldy     #$00
	sta     (sp),y
	lda     sp
	ldx     sp+1
	clc
	adc     #$05
	bcc     L0007
	inx
L0007:	jsr     __update_nt_text
;
; if (textBuf[strlen(textBuf) - 1] == '\n')
;
	ldx     #$FF
	ldy     #$01
L0009:	inx
	iny
	lda     (sp),y
	bne     L0009
	txa
	ldx     #$00
	sec
	sbc     #$01
	bcs     L000A
	dex
L000A:	clc
	adc     #$02
	bcc     L000B
	inx
	clc
L000B:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$0A
	bne     L0008
;
; yText++;
;
	inc     _yText
	bne     L000C
	inc     _yText+1
;
; xText = 0;
;
L000C:	tya
	sta     _xText
	sta     _xText+1
;
; if (textBuf[strlen(textBuf) - 1] == '\t')
;
L0008:	ldx     #$FF
	iny
L000E:	inx
	iny
	lda     (sp),y
	bne     L000E
	txa
	ldx     #$00
	sec
	sbc     #$01
	bcs     L000F
	dex
L000F:	clc
	adc     #$02
	bcc     L0010
	inx
	clc
L0010:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldx     #$00
	lda     (ptr1,x)
	cmp     #$09
	bne     L000D
;
; xText += strlen(textBuf) + 4;
;
	dex
	ldy     #$01
L0011:	inx
	iny
	lda     (sp),y
	bne     L0011
	txa
	ldx     #$00
	clc
	adc     #$04
	bcc     L0013
	inx
	clc
L0013:	adc     _xText
	sta     _xText
	txa
	adc     _xText+1
	sta     _xText+1
	tax
	lda     _xText
;
; }
;
L000D:	ldy     #$22
	jmp     leavey

.segment	"RODATA"

M0001:
	.byte	$00
	.res	31,$00

.endproc

; ---------------------------------------------------------------
; void __near__ nes_clear_nametable (unsigned int nametable)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nes_clear_nametable: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(nametable);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; vram_fill(0, 1024);
;
	lda     #$00
	jsr     pusha
	ldx     #$04
	jsr     _vram_fill
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ _print_nt_text (unsigned char x, unsigned char y, unsigned char *s)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__print_nt_text: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(NAMETABLE_A + (y << 5) + x);
;
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     tmp1
	clc
	adc     #$20
	sta     ptr1+1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L0006
	inx
L0006:	jsr     _vram_adr
;
; while (rda = *s++)
;
	jmp     L0004
;
; vram_put(rda - +NES_TEXT_TILE_INDEX - 0x20);
;
L0002:	lda     _rda
	sec
	sbc     #$20
	jsr     _vram_put
;
; while (rda = *s++)
;
L0004:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	sta     _rda
	tax
	php
	ldx     #$00
	lda     #$01
	jsr     addeq0sp
	plp
	bne     L0002
;
; }
;
	jmp     incsp4

.endproc

